---
weight: 10
title: Creative coding
---

* Creative coding

** Introduction

My research imperatives run along the threads of transmediation,
intersemiotic translation, post-disciplinarity (interdisciplinarity, multidiscplinarity) and the general concerns of Human Computer Interaction (HCI). 

#+BEGIN_QUOTE
*Key words:* big-data, connectivity, data, creative-coding, emacs, interaction, interdisciplinary, interconnection, machine learning, multidisciplinary, real-time, streaming, web 
#+END_QUOTE

* About

This blog communicates the experience of building tools for
interactive and data-driven
audiovisuality using creative coding environments and techniques.

It contains some basic information and tips (installations and usage) about emacs, SuperCollider, Raspberry pi.

Creative coding examples are enclosed in code blocks on the right
panel of this page. 

Programming languages: 

- C++,
- Shell,
- Python,
- emacs-lisp,
- SuperCollider

There is also a discusion about devices and protocols used for
interaction and communcation between user and machine as well as
between machine and machine.
 
Some examples are:

- midi controllers, 
- OSC communication,
- microcontrollers (arduino),
and physical computing,
- sensor usage, 
- multitouch technologies, etc. 

** Usage


- Interactive installations
- Computer Graphics
- Computer Music
- Machine learning
- Data driven creativity
- Sonification
- Visualisation



** Organising and sharing

organising and sharing projects using tools such as mass communication
techniques Git.

* Emacs

GNU Emacs
An extensible, customizable, free/libre text editor — and more.
At its core is an interpreter for Emacs Lisp, a dialect of the Lisp programming language with extensions to support text editing.
...[[https://www.gnu.org/software/emacs/][emacs]]

** Install packages

Install org-plus-contrib

#+BEGIN_SRC emacs-lisp

;; add this to your Emacs init file to be able to list the Org mode archives:

(require 'package)

(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

Then M-x list-packages RET will list both the latest org and
org-plus-contrib packages.

#+END_SRC
** Org-mode

** Create Headers

Start with an *asterisk* to make *Headers* and *two asterisks* for *Subheaders*

Example:

=* Header=

=** Subheader=

Give a *title* to your page using /hash/ (#) and /plus/ (+) symbols

Example: =#+Title: Getting started with org-mode=


*Hide* Numbers, table of contents

Example: =#+Options: num:nil toc:nil=

Write =#+= and press =Meta-<tab>= to see the list of variables

Example:

 =#+AUTHOR: Vasilis Agiomyrgianakis=

=#+DATE: 120416=

** Bulleting-Quoting

Use hyphen to make bullets

- bulleted
- list
- items

You can include quotations in Org mode documents like this:

=#+BEGIN_QUOTE=

'QUATATION'

=#+END_QUOTE=

#+BEGIN_QUOTE

QUATATION

#+END_QUOTE

** Markups

Give *emphasis* to your text.

Write your text *inside* the below symbols:

- 2 asterics for *Bold*,
- 2 slashes for /italics/,
- 2 equals signs for =verbatim=,
- 2 pluses for +strike through text+

*Bold*, /italics/, =verbatim=, +strikethrough+

** Linking 

 Press =C-c C-l= to *link* objects (files)

Example:

/Link: https//:basmyr.net/

Then give a name to the linked text

/Description: Basmyr.net/

 Press =C-c C-o= to *open* the linked plain text with an external program

[[http://basmyr.net][Basmyr.net]]

or a video url

[[https://youtu.be/Wr2aFlWyzvM][Granulator]]

** Tables

Use *pipes - vertical bars* to make tables

Example: Start with pipes and some text:

=| some | | Data |=

then hit return, pipe (vertical bar), hyphen and tab to extend the table verticaly

Press tab and the arrows keys to make arrangements on the table

| Some | Data  |
|------+-------|
|  234 | muons |
| 1200 | jets  |

** Images & Graphics
** Images

To insert an image with descriptions do the following:

#+BEGIN_QUOTE
Example-images
#+END_QUOTE

#+BEGIN_EXAMPLE
#+Caption: This is my image
#+Name: Fig 1
[[./images/myimage]]
#+END_EXAMPLE


** Ditaa



=#+BEGIN_SRC ditta :file image/awesome.png=

   _
  /_\__      _____  ___  ___  _ __ ___   ___
 //_\\ \ /\ / / _ \/ __|/ _ \| '_ ` _ \ / _ \
/  _  \ V  V /  __/\__ \ (_) | | | | | |  __/
\_/ \_/\_/\_/ \___||___/\___/|_| |_| |_|\___|

=#+END_SRC=


=C-c C-c= to evaluate lisp code inside source block

*Find the path of ditaa.jar in you computer through a lisp program*


#+BEGIN_SRC emacs-lisp

(expand-file-name
             "ditaa.jar"
      (file-name-as-directory
            (expand-file-name
                "scripts"
               (file-name-as-directory
                  (expand-file-name
                      "../contrib"
                     (file-name-directory (org-find-library-dir "org")))))))
#+END_SRC


** Export to other formats

Pressing =C-c C-e= popups a buffer to *export* markups to HTML-PDF-etc.

Example: hit =h= and =o= if you want to *export and open as html*.

Export Beamer: =C-c C-e l P=     =(org-beamer-export-to-pdf)=

Export PDF: =C-c C-e l O=

Export as LaTeX,  and open PDF file.

** Source Code

Create code blocks to insert your code.

Press =C-c '= *inside the SRC block* to edit the current code block

in the mode of the language you want. For instance:

 =#+BEGIN_SRC emacs-lisp=

write some lisp to make your configurations in org-mode

so as to see bullets (UTF-8 characters) when you editing *Headers* in org-mode instead of asterisks.

Then close the source block with:

=#+END_SRC=

*Result*

#+BEGIN_SRC emacs-lisp

     (require 'org-bullets)
(add-hook 'org-mode-hook
          (lambda () (org-bullets-mode 1)))


#+END_SRC

*You can customise source blocks using =M-x customize-face RET= face RET*

Evaluate source code. Press C-c C-c inside the block and see the results.

 #+BEGIN_SRC shell
 
echo "Hello $USER! Today is `date`"
  #+END_SRC

** LaTeX integrator

- Characters: \alpha \rightarrow \beta
- $O(n \log n)$


\begin{align*}
q = 2 * 4 + 1 - 2 &= 7 \\
         q &=7
\end{align*}

** Shortcuts Tips

write down =<s= and press =tab= to open src blocks,

=<q= tab for Quotes,

=<e= tab for Examples

=<c= tab for Center

etc.

to cooment a =lisp= region select a word or a region with C-M-space and then M-; to comment

** Change read-only files on emacs

=M-x toggle-read-only=

** TO DO
type TODO to create a todo object
Move the cursor one line after the TODO item and press =C-c C-s= =(org-schedule)=
to schedule with agenda

#+BEGIN_QUOTE
 TODO Call John
SCHEDULED: <2016-11-09 Wed>
#+END_QUOTE

#+BEGIN_QUOTE
 TODO read this and that
SCHEDULED: <2016-11-10 Thu>
#+END_QUOTE

#+BEGIN_QUOTE
 DONE export html minted  (highlight colour - syntax source blocks)
SCHEDULED: <2016-10-12 Wed>
#+END_QUOTE

To open week-agenda window press C-ca
To schedule a TODO item press C-c C-s
Use shift-arrows to change dates


** Github

Introduction to Environments (Github or Bitbucket) for organizing and sharing files-Git.
Set up an account with Slack and Github.

#+BEGIN_QUOTE
Github
#+END_QUOTE

 organize projects and share the
individual processes using tools such as mass communication techniques
Slack-Git.

Git:

- Create a Repository
- Create a Branch
- Make a Commit
- Push and Commit.

[[https://guides.github.com/activities/hello-world/][GitHub Hello world]]


[[https://gist.github.com/davfre/8313299][Github example]]

Https://guides.github.com/activities/hello-world/,
Https://gist.github.com/davfre/8313299

 
** install package magit and usage

#+BEGIN_QUOTE
Magit
#+END_QUOTE

Download 
[[https://github.com/magit/magit%20][Magit]]

Install Magit from MELPA

Dired to the folder you want to create the .git file and press

=M-x magit-init= and press =y=

Then press M-x magit-remote-add

add remote rep to master or origin


Backup rep online in GIThub

First, create an ssh key to gain access into your repositories in Github

 Concatanate keys from term

ie. //cat id_rsa.pub | pbcopy


Press =C-x m= to display information about the current Git repository

Press =C-x g= for magit-status 

=s= to stage files

=c-c=  (write a comment) and then press =C-c C-c= to commit


The next step is to push to  a remote branch on Github.

Press =Shift-p p= to push to a remote branch (master).

=P-p= to push to remote


** Pull requests

*issues*

- Git refusing to merge unrelated histories

git cherry-pick -m 1 1234deadbeef1234deadbeef
git rebase --continue

merge

Git failed...

Git refusing to merge unrelated histories

in magit press h to bring the popoup and choose rebase -r and then -p

 
** Install Dictionaries -emacs

*Install aspell from brew*

#+BEGIN_SRC shell

$ brew install aspell --with-lang-en --with-lang-el --with-lang-de

#+END_SRC

for English, Hellenic and Deutsch languages.

if you have problems installing aspell with the above code

just do only:

#+BEGIN_SRC shell

$ brew install aspell

#+END_SRC

*Install aspell using downloaded packages aspell-0.60.6.1*

go to terminal and type:

#+BEGIN_SRC shell
$ cd ~/aspell path
$ ./configure
$ make
$ make install
#+END_SRC

To install additional dictionary download the language you prefer from  [[ftp://ftp.gnu.org/gnu/aspell/dict/0index.html][GNU_Available Aspell Dictionaries]]

i.e =aspell-el-0.50-3= for Hellenic language (Greek)

and go to terminal and type:

#+BEGIN_SRC shell
$ cd ~/dictionary path
$ ./configure
$ make
$ install
#+END_SRC

*Switch dictionary*

To switch between dictionaries run:

M-x: =ispell-change-dictionary=

and write /greek/ for Hellenic language auto-correct

Press F6 (fn-F6) to switch between dictionaries (british, greek, german)

If you want to use the english dictionary in a particular buffer instead,
put the following on the first line of the buffer:

=-*- ispell-dictionary: "english" -*-=

*Use flyspell instead of ispell*

#+BEGIN_SRC lisp
(setq ispell-list-command "--list")
#+END_SRC
 
** text expansion

install YASnippet using MELPA

put the below into your init.el

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path
             "~/.emacs.d/plugins/yasnippet")
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

quit emacs and open again and type

=M-x yas-new-snippet=

- Give a name to your snippet
- give the abrev
- write your text or code you want to be expanted
- save file C-c C-c
- choose a table i.e prog-mode
- give a name to your snippet (I use the abrev key as the name)

try using the abrev key and press tab to expant your text.


** Searching 

Press =C-s= to search with I-search.

You can also try:

C-h f (or M-x describe-function) will show you the bindings for a command.
C-h b (or M-x describe-bindings) will show you all bindings.
C-h m (M-x describe-mode) is also handy to list bindings by mode.
You might also try C-h k (M-x describe-key) to show what command is bound to a key.


See also =helm swoop=


There is also the =projectile=. To use projectile make sure you have created a
.git repo into your project. 

Press =C-cpp= to open projectile
and search for projects
 
** Export references to pdf with org-mode - bibtex

Use bibtex package for citation.

First put the bellow code in your ./emacs

#+BEGIN_SRC emacs-lisp
;; Bibtex-latex export citation
(setq org-latex-pdf-process
      '("latexmk -pdflatex='pdflatex -interaction nonstopmode' -pdf -bibtex -f %f"))

#+END_SRC

Your next step is to create a .bib file with your citations and name it i.e: test-bib-refs

Below is an example of bibtex style


#+BEGIN_SRC latex
@ARTICLE{2011ApJS..192....9T,
   author = {{Turk}, M.~J. and {Smith}, B.~D. and {Oishi}, J.~S. and {Skory}, S. and
     {Skillman}, S.~W. and {Abel}, T. and {Norman}, M.~L.},
    title = "{yt: A Multi-code Analysis Toolkit for Astrophysical Simulation Data}",
  journal = {The Astrophysical Journal Supplement Series},
archivePrefix = "arXiv",
   eprint = {1011.3514},
 primaryClass = "astro-ph.IM",
 keywords = {cosmology: theory, methods: data analysis, methods: numerical },
     year = 2011,
    month = jan,
   volume = 192,
      eid = {9},
    pages = {9},
      doi = {10.1088/0067-0049/192/1/9},
   adsurl = {http://adsabs.harvard.edu/abs/2011ApJS..192....9T},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

#+END_SRC

#+BEGIN_QUOTE
and this:
#+END_QUOTE


#+BEGIN_SRC latex
@InProceedings{ alejandro_weinstein-proc-scipy-2016,
  author    = { {A}lejandro {W}einstein and {W}ael {E}l-{D}eredy and {S}téren {C}habert and {M}yriam {F}uentes },
  title     = { {F}itting {H}uman {D}ecision {M}aking {M}odels using {P}ython },
  booktitle = { {P}roceedings of the 15th {P}ython in {S}cience {C}onference },
  pages     = { 1 - 6 },
  year      = { 2016 },
  editor    = { {S}ebastian {B}enthall and {S}cott {R}ostrup }
}

#+END_SRC

 then use these latex commands inside your org file

#+BEGIN_Example
#+LaTeX_HEADER: \usepackage[natbib]{biblatex}
#+LATEX_HEADER: \bibliographystyle{plain}
#+LATEX_HEADER: \bibliography{test-bib-refs}
#+END_Example

** Tests

** Test1 slide

   - This is test1 

#+BEGIN_QUOTE
\cite{2011ApJS..192....9T}.
#+END_QUOTE

   - This is test2

#+BEGIN_QUOTE
\cite{alejandro_weinstein-proc-scipy-2016}.
#+END_QUOTE   
 


#+BEGIN_QUOTE
\printbibliography
#+END_QUOTE




#+BEGIN_QUOTE
 *Note: put =\printbibliography= at the end so as to print the references section last on your text.
#+END_QUOTE


* SuperCollider

From: [[http://supercollider.github.io][SuperCollider]]

** Basics

SuperCollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists, and researchers working with sound. It is free and open source software available for Windows, macOS, and Linux.

** SuperCollider features three major components:

- *scsynth*, a real-time audio server, forms the core of the platform. It features 400+ unit generators ("UGens") for analysis, synthesis, and processing. Its granularity allows the fluid combination of many known and unknown audio techniques, moving between additive and subtractive synthesis, FM, granular synthesis, FFT, and physical modelling. You can write your own UGens in C++, and users have already contributed several hundred more to the sc3-plugins repository.
- *sclang*, an interpreted programming language. It is focused on sound, but not limited to any specific domain. sclang controls scsynth via Open Sound Control. You can use it for algorithmic composition and sequencing, finding new sound synthesis methods, connecting your app to external hardware including MIDI controllers, network music, writing GUIs and visual displays, or for your daily programming experiments. It has a stock of user-contributed extensions called Quarks.
- *scide* is an editor for sclang with an integrated help system.


  
** Nodes

From: [[https://composerprogrammer.com/teaching/supercollider/sctutorial/6.3%2520Nodes.html][composerprogrammer.com]]

The Server has a graph of all the running Synths, which may be organised into Groups for convenience. You can see Synths and Groups being created just by looking at the Server graphics.

A Node means a Synth or a Group. Whenever you press command+period you reset the graph, cleaning out all the Synths and Groups you added, that is, clearing all Nodes.

The initial state of the Node graph on the Server looks like this (do command+period first to destroy any existing nodes so you have the starting state):

#+BEGIN_SRC js
s.queryAllNodes //run me to see the Nodes on the Server
#+END_SRC

The two default Nodes are convenient Groups for putting your Synths into.

Group(0) is the absolute root of the tree. All new Synths get placed within this Group somewhere (they might be in subGroups but they will be within the RootNode Group at the top of the hierarchy).

#+BEGIN_SRC js
r=RootNode.new; //this gets a reference to Group(0)
#+END_SRC

Group(1) was added as an additional default to receive all created Synths, to avoid cluttering the base of the tree.

#+BEGIN_SRC js
Group.basicNew(s, 1); //this gets a reference to Group(1)
#+END_SRC




** Find recordings folder

#+BEGIN_SRC js
thisProcess.platform.recordingsDir;
#+END_SRC



** Synthesis techniques 


Introduction to sound design (origin, definition, procedures, application fields).

#+BEGIN_QUOTE
SuperCollider example:
Creating a sine wave
#+END_QUOTE


#+BEGIN_SRC js
{SinOsc.ar(440, 0, 0.3)}.play
#+END_SRC

#+BEGIN_QUOTE
Additive synthesis
#+END_QUOTE
#+BEGIN_SRC js
{SinOsc.ar(440, 0, 0.4)+SinOsc.ar(660, 0, 0.3)}.play;
#+END_SRC

#+BEGIN_QUOTE
Subtractive synthesis
#+END_QUOTE

#+BEGIN_SRC js
{LPF.ar(SinOsc.ar(440, 0, 0.4), 6000, 0.3)}.play;
#+END_SRC

#+BEGIN_QUOTE
Granular synthesis
#+END_QUOTE

#+BEGIN_SRC js

SynthDef(\granular, {|out = 0, trig = 1, dur = 0.1, sndbuf, pos = 0.2, 
rate = 1, pan = 0, amp = 0.4|
var env, source;
env = EnvGen.kr(Env.adsr, 1, doneAcion: 2);
source = Out.ar(out, GrainBuf.ar(2, Impulse.kr(trig), dur, sndbuf, rate, pos, 2,
pan, envbuf) * env)
}).add;

#+END_SRC



** Input Devices


Musical gestures can be expressed through a wide range of body
movements. Dozens of input devices have been developed to capture
these gestures. (Roads 1996: 625)

#+BEGIN_QUOTE
Switch
Push buttons
Linear potentiometer or fader
Trackball
Joystick
Game Paddles
etc
#+END_QUOTE
** Instrument design


[[http://bela.io][Bela]]


Capacitive touch sensor-raspberry pi

[[https://learn.adafruit.com/mpr121-capacitive-touch-sensor-on-raspberry-pi-and-beaglebone-black/overview][MPR121]] 




** Mapping the Data from the Input Device

The message coming from digital input devices are streams of binary
numbers. A microprocessor inside the receiving synthesizer must decode
these streams before commanding the synthesis engine  to emit
sound. (Roads 1996: 625)


** Remote Controllers


* iPython


Introduction to Python (https://www.python.org/doc/).


#+BEGIN_QUOTE
Python
#+END_QUOTE

#+BEGIN_SRC python

# Python 3: Fibonacci series up to n
 def fib(n):
     a, b = 0, 1
     while a < n:
         print(a, end=' ')
         a, b = b, a+b
     print()
 fib(1000)

#+END_SRC



** IPython-notebook

- IPython notebook is used to analyse data and for data visualisation.


- IPython is the component in the toolset that ties everything together; it provides a robust and productive environment for interactive and exploratory computing.

- ipython noteboook uses a client-server model. This makes it possible to interact with ipython from several different environments. For example, emacs or a web browser.

For more info see: https://ipython.org

Two other key components are [[https://jupyter.org][Jupyter Notebooks]] and [[https://www.continuum.io][Anaconda]]. Jupyter provides Mathematica like notebooks and Anaconda is a package management system.

Jupyter Notebooks, originally called
IPython Notebooks,and it commonly used for improving the reproducibility and accessiblity of scientific research.


** Other math/science/data oriented Python tools

- Scikit - machine learning
- Scikit-image & PIL/Pillow - image processing
- Blaze - data transformation pipelines & simplified interactions with various data stores
- Bokeh - Interactive web visualisations
- Sympy - symbolic algebra (also see Sage)
- YT - for analysing and visualising volumetric data
- Numba - a very easy to use JIT compiler (just import it and put @jit annotation on functions you want compiled) and for dealing with genuinely big data there is PySpark and Ibis.

** Install ipython on emacs:

First install anaconda:
https://www.continuum.io/downloads
check your python version in terminal =python --version= i.e /3.5/, and download anaconda3.

After downloaded anaconda open terminal and =cd= to anacoda3 directory and type:

#+BEGIN_SRC sh
bash Anaconda3-4.3.0-MacOSX-x86_64.sh
#+END_SRC

press yes for anaconda3 to add the =PATH= to your /.bash_profile/

The next step is to:

- install ipython on emacs. One of the packages is called /[[https://github.com/tkf/emacs-ipython-notebook][ein]]/ and you can install it through  *melpa*.

copy *ein.el* and *ein.py* to your emacs upload directory

- open =.emacs.d= and write

#+BEGIN_SRC lisp
(require 'ein)
#+END_SRC

Start IPython notebook server.
Go to terminal and write: =jupyter notebook= then copy the /token/ and paste it as the password to login to the server.

On emacs hit =M-x ein:notebooklist-login= and press /return/ to use the =localhost:8888=, server and use the token (password) to login.

i.e =password: 8b6cae64f7dbcfc425a2dsf30cretfdfc7d730dcba9180ab8=

*Term output example*:

#+Begin_SRC shell

[I 01:49:54.596 NotebookApp] Serving
notebooks from local directory: /Users/usr_name
[I 01:49:54.596 NotebookApp] 0 active kernels
[I 01:49:54.597 NotebookApp] The Jupyter Notebook is running at:
http://localhost:8888/?token8b6cae64f7dbcfc425a2dsf30cretfdfc7d730dcba9180ab8
[I 01:49:54.597 NotebookApp] Use Control-C to stop this server and shut
down all kernels (twice to skip confirmation).
[C 01:49:54.626 NotebookApp]

    Copy/paste this URL into your browser when you connect for the first time,
    to login with a token:

  http://localhost:8888/?token=8b6cae64f7dbcfc425a2dsf30cretfdfc7d730dcba9180ab8
#+End_SRC

If you successfully logged in to the server;

Hit =M-x ein:notebooklist-open= to open the notebook list. This will open a notebook list buffer.

In the notebook list buffer, you can open notebooks by hitting [Open], [Dir] for directories, create new notebook [New notebook], delete notebook [Delete].

*NOTE*
You can also check [[http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-python.html][ob-python]] package for *source code block ipython in org-mode*

You can start testing ipython using these examples:
 /[[https://github.com/particle-physics-playground/playground][particle-physics-playground-playground-52de62d]]/


#+BEGIN_QUOTE
CERN examples: /particle-physics-playground-playground-52de62d/

#+END_QUOTE

** Sonifying ems (muons) - ipython - SuperCollider in emacs 

Editor: Emacs Version 24.5 (9.0)

Ipython package **ein** on MELPA

SuperCollider 3.7

Data sonification experiment on particle-physics-playground.

For more info see here: 

[[https://github.com/particle-physics-playground][particle-physics-playground]]

  
- Sending OSC messages to other application

to send osc messages to other application install *python-osc* library

In this case I use SuperCollider port *57120*

#+BEGIN_QUOTE
SuperCollider
#+END_QUOTE

#+BEGIN_SRC js
// BA 28022017
// Testing osc communication - Receiving data from ipython - 'CMS' (Compact Muon Solenoid) __

s.boot // boot the server
s.record // record
s.stopRecording // stop recording


// create synthdef
(
SynthDef(\ipythontest, {|
	freq = 440, gate = 1,
amp = 0.5, out = 0|
	var env, source;
	
	env = EnvGen.kr(Env.adsr, 1, doneAction:2);

	//source = SinOsc.ar(freq*2, 0, amp);
	source = SinOsc.ar(SinOsc.ar(freq*2, freq*4, freq*2), 0,  amp);
	// source  = UseWhateverGen.ar();

	
	Out.ar(out, Pan2.ar(source*env, 0))!2
}).add;

~x=Synth(\ipythontest, [\freq, 440, \amp, 0.5]); // run the synth


// set osc

~a = OSCdef(\oscTest,
	{
			| ... msg | msg.postln;
	
			~x.set(\freq, msg, \amp, 0.9);
		//~muons = msg [0] [1..];
		//~muons.postln;



		// use the osc messages (msg) for the frequency
	},
	'/print' // OSCmessage name 
);
)

#+END_SRC


#+BEGIN_QUOTE
ipython notebook
#+END_QUOTE

#+BEGIN_SRC python

#VA_exp_280217_001


#Import libraries numpy, matplotlib, pythonosc

In [1]
import numpy as np
import matplotlib.pylab as plt

from IPython import get_ipython
get_ipython().run_line_magic('matplotlib', 'inline')

In [2]
#from __future__ import print_function
#from __future__ import division
import sys

sys.path.append("../particle-physics-playground-Sonification-Example_001/tools/")

#from draw_objects3D import *
import cms_tools as cms



#+END_SRC

#+BEGIN_SRC python
 
In [3]
infile = open('../particle-physics-playground-Sonification-Example_001/data/small_cms_test_file.dat')

collisions = cms.get_collisions(infile)

number_of_collisions = len(collisions)
print ("# of proton-proton collisions: %d" % (number_of_collisions))


# of proton-proton collisions: 10


In [4]
print (collisions[0])


[[[88.9127, 32.9767, -75.1939, 29.541, -1.0], [79.2211, -58.6558, 49.1723, 13.5915, -1.0], [43.313, -5.9129, 40.0892, 12.0431, -1.0], [274.8094, -21.4194, 27.5639, -272.4152, -1.0], [26.6201, 0.5268, -24.7563, -7.4046, 0.0]], [[15.7375, 1.4793, -15.2566, -3.5645, -1]], [], [[52.364, 17.4983, -45.4233, 19.3009], [10.2904, -1.4633, 10.0887, 1.4035]], [44.9415, 0.422]]


In [5]

print (len(collisions[0]))

5


In [6]
METx = collisions[0][4][0]
METy = collisions[0][4][1]

print ("MET x: %f" % (METx))
print ("MET y: %f" % (METy))

MET x: 44.941500
MET y: 0.422000


In [7]
print ("# of jets:      %d" % (len(collisions[0][0])))
print ("# of muons:     %d" % (len(collisions[0][1])))
print ("# of electrons: %d" % (len(collisions[0][2])))
print ("# of photons:   %d" % (len(collisions[0][3])))

# of jets:      5
# of muons:     1
# of electrons: 0
# of photons:   2


In [8]
jets,muons,electrons,photons,met = collisions[0]


In [9]
E,px,py,pz,btag = jets[0]
print ("E:     %8.4f" % (E))
print ("px:    %8.4f" % (px))
print ("py:    %8.4f" % (py))
print ("pz:    %8.4f" % (pz))
print ("btag:  %8.4f" % (btag))

E:      88.9127
px:     32.9767
py:    -75.1939
pz:     29.5410
btag:   -1.0000


In [10]
E,px,py,pz,q = muons[0]
print ("E:  %8.4f" % (E))
print ("px: %8.4f" % (px))
print ("py: %8.4f" % (py))
print ("pz: %8.4f" % (pz))
print ("q:  %8.4f" % (q))

E:   15.7375
px:   1.4793
py: -15.2566
pz:  -3.5645
q:   -1.0000


In [11]
E,px,py,pz = photons[0]
print ("E:  %8.4f" % (E))
print ("px: %8.4f" % (px))
print ("py: %8.4f" % (py))
print ("pz: %8.4f" % (pz))

E:   52.3640
px:  17.4983
py: -45.4233
pz:  19.3009


In [0]
      # Plot the quantities
plt.figure(figsize=(16,4))

plt.subplot(1,3,1)
plt.hist(njets,bins=5,range=(0,5))
plt.xlabel(r'# of jets')
plt.ylabel('# entries')

plt.subplot(1,3,2)
plt.hist(jets_E,bins=25,range=(0,400))
plt.xlabel(r'Jet energy [GeV]')
plt.ylabel('# entries')

plt.subplot(1,3,3)
plt.hist(muons_E,bins=25,range=(0,400))
plt.xlabel(r'Muon energy [GeV]')
plt.ylabel('# entries')

h1:
Watch an example

In [0]
from IPython.display import YouTubeVideo
YouTubeVideo('UfimSbOr9to')

In [13]
infile = open('../particle-physics-playground-Sonification-Example_001/data/mc_dy_1000collisions.dat')


collisions = cms.get_collisions(infile)

# We will use these to store the quantities that we will be plotting later.
njets = []
jets_E = []
muons_E = []
photons_E = []

for collision in collisions:
    
    jets,muons,electrons,photons,met = collision
    
    njets.append(len(jets))
    
    for jet in jets:
        E,px,py,pz,btag = jet
        jets_E.append(px)

    for muon in muons:
        E,px,py,pz,q = muon
        muons_E.append(E)
        
    for photon in photons:
        E,px,py,pz = photon
        photons_E.append(E)

  



#+END_SRC

#+BEGIN_SRC python

In [18]
import time

infile = open('../particle-physics-playground-Sonification-Example_001/data/mc_dy_1000collisions.dat')


collisions = cms.get_collisions(infile)

# We will use these to store the quantities that we will be plotting later.
njets = []
jets_E = []
muons_E = []
photons_E = []

for collision in collisions:
    
    jets,muons,electrons,photons,met = collision
    
    njets.append(len(jets))
    
    for jet in jets:
        E,px,py,pz,btag = jet
        jets_E.append(E )

    for muon in muons:
        E,px,py,pz,q = muon
        muons_E.append(E)
        
    for photon in photons:
        E,px,py,pz = photon
        photons_E.append(E)

        
             # Set up OSC here
  
from pythonosc import osc_message_builder
from pythonosc import udp_client

# The port for SuperCollider is '57120'

client = udp_client.SimpleUDPClient("127.0.0.1", 57120)


#client.send_message("/print", muons_E)

# now we can print them out too

for i in muons_E:
      print ("muon was: %d" % i)
      client.send_message("/print", i)
      time.sleep(0.015)

for i in jets_E:
      print ("jet was: %d" % i)
      client.send_message("/print", i)
      time.sleep(0.015)

for i in photons_E:
      print ("photon was: %d" % i)
      client.send_message("/print", i)
      time.sleep(0.015)
# # Plot the quantities


#+END_SRC


* Micro-computing


** Physical computing

Introduction to physical computing - microcontrollers. Programming
Interactivity (Noble 2012): Chapter 4: Arduino.

Introduction to Raspberry Pi
(https://www.raspberrypi.org/learning/hardware-guide/).

** Interactive Performance.

  Artistic methods and techniques which give to performers (usually dancers or musicians) control of their medium in real time.

 wireless sensors found both in the body of an performer and in the
 theater.

** Sensors

Use of sensors: touch, movement, elasticity, camera.

*Programming Interactivity* 

experimenting with various sensors.

experimenting with Arduino and node.js

Arduino basic examples:
(https://www.arduino.cc/en/Tutorial/BuiltInExamples).

Using Python-for OSC communication libraries 

(https://pypi.python.org/pypi/python-osc) - with SuperCollider.

** Raspberry Pi

 
Install Linux Raspbian Jessie Lite OS Image on the SD card

Download Raspbian here:
[[https://www.raspberrypi.org/downloads/raspbian/][raspbian]]

Follow the instructions here:
[[https://www.raspberrypi.org/documentation/installation/installing-images/README.md][installation-guide]]



** Installing raspbian jessie-lite on raspberry

** Import your SD card to your mac

Go to check the disk number on /About this mac->System report/

it will be like disk2s1

Then open disk utilities choose the partision of the SD card and unamount it so as to let you erase it.

Then open terminal and write the following

#+BEGIN_SRC shell
$ sudo dd bs=1m if=path_of_your_image.img of=/dev/rdiskn
#+END_SRC


Remember to replace =n= with the number that you noted before!

eject sd card and connect it to raspberry

** Set up network

login from external screen and edit wpa_supplicant.conf

Also enabled SSH while having the raspberry pi on the external monitor...

open raspi config

#+BEGIN_SRC shell
$ sudo raspi-config
#+END_SRC

Go to =Advanced Options=
and enable ssh and reboot

When you try to connect using ssh pi@raspnberrypi.local you might come across with this warning

#+BEGIN_SRC shell

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@       WARNING: POSSIBLE DNS SPOOFING DETECTED!          @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
The ECDSA host key for raspberrypi.local has changed,
and the key for the corresponding IP address uu
has a different value. This could either mean that
DNS SPOOFING is happening or the IP address for the host
and its host key have changed at the same time.
Offending key for IP in /Users/user/.ssh/known_hosts:7
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
h. Please contact your system administrator.
Add correct host key in /Users/vasilis/.ssh/known_hosts to get rid of this
 message.
Offending ECDSA key in /Users/vasilis/.ssh/known_hosts:19
ECDSA host key for raspberrypi.local has changed and you have requested strict
 checking.
Host key verification failed.

#+END_SRC

To solve the problem try to delete previous keys in =known_hosts= file like pi@raspnberrypi.local

then try to login 
#+BEGIN_SRC shell
$ ssh pi@raspnberrypi.local
#+END_SRC 


and type =yes= to accept a new permanent key for local.

After that go and update

#+BEGIN_SRC shell
$ pi@raspberrypi:~ $ sudo apt-get update
#+END_SRC
and upgrade

#+BEGIN_EXAMPLE
$ pi@raspberrypi:~ $ sudo apt-get upgrade
#+END_EXAMPLE

then you can start installing software such as SuperCollider, emacs etc.

** Ethernet set up

[[http://supercollider.github.io/development/building-raspberrypi][Building from Source on Raspberry]]

#+BEGIN_QUOTE
- connect an ethernet cable from the network router or your computer to the rpi
- insert the sd card and usb soundcard
- last connect usb power from a 5V@1A power supply

#+END_QUOTE


** Install emacs

#+BEGIN_SRC shell
pi@raspberrypi:~ $ sudo apt-get install emacs=
#+END_SRC

quick installation of prelude emacs

#+BEGIN_SRC shell
pi@raspberrypi:~ $ curl -L https://git.io/epre | sh
#+END_SRC

The =Meta= key in terminal emacs is the =ESC= key
So press =ESC-x= for =Meta-x=

next step is to install supercollider in emacs

** Install SupeCollider on RPI

Installation guide from: [[http://supercollider.github.io/development/building-raspberrypi][Building SC on RPI]]

#+BEGIN_SRC shell
$ ssh pi@raspberrypi.local #from your laptop, default password is raspberry
$ sudo raspi-config #change password, expand file system, reboot and log in again with ssh
#+END_SRC

#+BEGIN_QUOTE
update the system, install required libraries & compilers
#+END_QUOTE

#+BEGIN_SRC shell
$sudo apt-get update

$sudo apt-get upgrade

$sudo apt-get install alsa-base libicu-dev libasound2-dev libsamplerate0-dev libsndfile1-dev libreadline-dev libxt-dev libudev-dev libavahi-client-dev libfftw3-dev cmake git gcc-4.8 g++-4.8

#+END_SRC

#+BEGIN_QUOTE
compile & install jackd (no d-bus)
#+END_QUOTE

#+BEGIN_SRC shell
$git clone git://github.com/jackaudio/jack2 --depth 1
$cd jack2
$./waf configure --alsa #note: here we use the default gcc-4.9
$./waf build
$sudo ./waf install
$sudo ldconfig
$cd ..
$rm -rf jack2
$sudo nano /etc/security/limits.conf #and add the following two lines at the end
    * @audio - memlock 256000
    * @audio - rtprio 75
 exit #and log in again to make the limits.conf settings work

#+END_SRC

#+BEGIN_QUOTE
compile & install sc master
#+END_QUOTE

#+BEGIN_SRC shell
$git clone --recursive git://github.com/supercollider/supercollider
#optionally add –depth 1 here if you only need master
$cd supercollider
$git submodule init && git submodule update
$mkdir build && cd build
$export CC=/usr/bin/gcc-4.8 #here temporarily use the older gcc-4.8
$export CXX=/usr/bin/g++-4.8
$cmake -L -DCMAKE_BUILD_TYPE="Release" -DBUILD_TESTING=OFF -DSSE=OFF -DSSE2=OFF
-DSUPERNOVA=OFF -DNOVA_SIMD=ON -DNATIVE=OFF -DSC_ED=OFF
-DSC_WII=OFF -DSC_IDE=OFF -DSC_QT=OFF -DSC_EL=OFF -DSC_VIM=OFF
-DCMAKE_C_FLAGS="-mtune=cortex-a7 -mfloat-abi=hard -mfpu=neon
-funsafe-math-optimizations" 
-DCMAKE_CXX_FLAGS="-mtune=cortex-a7 -mfloat-abi=hard -mfpu=neon
-funsafe-math-optimizations" ..
$make -j 4 #leave out flag j4 on single core rpi models
$sudo make install
$sudo ldconfig
$cd ../..
$rm -rf supercollider
$sudo mv /usr/local/share/SuperCollider/SCClassLibrary/Common/GUI
/usr/local/share/SuperCollider/SCClassLibrary/scide_scqt/GUI
$sudo mv /usr/local/share/SuperCollider/SCClassLibrary/JITLib/GUI
/usr/local/share/SuperCollider/SCClassLibrary/scide_scqt/JITLibGUI
#+END_SRC

#+BEGIN_QUOTE
start jack & sclang & test
#+END_QUOTE

#+BEGIN_SRC shell
$jackd -P75 -dalsa -dhw:1 -p1024 -n3 -s -r44100 & 
#edit -dhw:1 to match your soundcard. usually it is 1 for usb, or,jackd -P75-dalsa -dhw:UA25EX -p1024
-n3 -s -r44100 &
$sclang #should start sc and compile the class library with 
only 3 harmless class overwrites warnings
    $s.boot #should boot the server
    $ a= {SinOsc.ar([400, 404])}.play #should play sound in both channels
    $ a.free
     {1000000.do{2.5.sqrt}}.bench #benchmark: ~0.89 for rpi2, ~3.1 for rpi1
    $ a= {Mix(50.collect{RLPF.ar(SinOsc.ar)});DC.ar(0)}.play#benchmark
    $ s.dump #avgCPU should show ~19% for rpi2 and ~73% for rpi1
    $ a.free
    $ 0.exit #quit sclang
$ pkill jackd #quit jackd
#+END_SRC

** Run SuperCollider on emacs

[[http://supercollider.github.io/development/building-raspberrypi][raspberrypi_SuperCollider]]

create directory =packages= in =~/emacs.d/personal/=

and =mv /directory-of-scel/el/ to /packages-directory/=

then write in the init.el file

#+BEGIN_SRC emacs-lisp

(add-to-list ~/.emacs.d/personal/packages/el)
(require 'sclang)

#+END_SRC


Create an =Extensions= directory in
=/usr/local/share/SuperCollider/=

and cp the =sc= directory from
=~/supercollider/editors/scel/sc=
to =/usr/local/share/SuperCollider/Extensions/=

Then type to the terminal

#+BEGIN_SRC shell
pi@raspberrypi:~ $ jackd -P75 -dalsa -dhw:1 -p1024 -n3 -s -r44100 &
//pi@raspberrypi:~ $ scsynth -u 57110 &
pi@raspberrypi:~ $ emacs -sclang

#+END_SRC



Copy directories from mac to pi using terminal


#+BEGIN_SRC shell
$ scp -r /path/to/directory pi@raspberrypi:~/path/to/remote/dir

#+END_SRC


example:

#+BEGIN_SRC shell
$ scp -r /Users/path pi@raspberrypi:~/SC_Stuff
#+END_SRC






** Open raspberrypi3 from  emacs using TRAMP

=C-x C-f= and type

#+Begin_SRC shell
 /ssh:pi@raspberrypi:
#+End_SRC

then type your raspberry password

#+Begin_EXAMPLE
 pass: *******
#+End_EXAMPLE

and then dired freely, open files and programms using  shell as well to run sclang

** Edit and save files using tramp

=C-x C-f= and type

#+BEGIN_SRC shell
/ssh:pi@raspberrypi|sudo:root@pi@raspberrypi:
#+END_SRC

dired to your file, make changes and save it!!!


** Copy files from Raspberrypi to mac and the opposite


#+BEGIN_SRC shell
scp /path/to/py/file pi@raspberrypi:~
#+END_SRC

Replace raspberrypi with the ip address of the Pi if using the hostname doesn't work.

or from the pi

#+BEGIN_SRC shell
scp macuser@macipaddress:/path/to/py/file ~

#+END_SRC

replace macuser and macipaddress with your mac user and mac's ip address.



https://www.raspberrypi.org/forums/viewtopic.php?t=35152&p=296946

The following syntax is used to rename files with mv:


=mv (option) filename1.ext filename2.ext=

** Use rsync

On your mac go to the directory you want to sync using *cd* on your terminal and type the following command:

transfering files from raspberry to mac

#+BEGIN_SRC shell
 Recordings git:(SuperCollider) ✗ rsync -avz -e ssh pi@192.168.1.96:/home/pi/.local/share/SuperCollider/Recordings/ Recordings/

#+END_SRC

and

#+BEGIN_SRC shell
voices git:(SuperCollider) ✗ rsync -avz -e ssh pi@192.168.1.96:~/sounds/voices/ voicesA/
pi@192.168.1.96's password:
receiving file list ... done
created directory Weaving-voices
#+END_SRC

transfering files from mac to raspberry

#+BEGIN_SRC shell
$ rsync -avP sounds/ pi@192.168.1.96:~/sounds/voices/voicesA/
#+END_SRC

Unfortunatelly it doesnt work with the name of the raspberry instead you need to find the ip of raspberry. To find the ip ssh to your raspberry and type:

#+BEGIN_SRC shell
$ sudo ifconfig
#+END_SRC


it will ask for the pass word:

#+BEGIN_SRC shell
pi@192.168.1.96's password:
receiving file list ... done
created directory Recordings
./
SC_161215_114846.aiff
SC_170422_120739.aiff
SC_170422_135403.aiff

sent 88 bytes  received 11223209 bytes  477587.11 bytes/sec
total size is 25854264  speedup is 2.30
➜  Recordings git:(SuperCollider) ✗

#+END_SRC



** Install Adafruit MPR121 on Raspberry

** Soldering

Prepare the header strip, Add the breakout board, and solde

see more [[https://learn.adafruit.com/adafruit-mpr121-12-key-capacitive-touch-sensor-breakout-tutorial/assembly][here]]

After you've soldered the sensor to the header strip move to wiring sesion:

** Wiring

Wiring
Place the MPR121 board into a breadboard and connect its inputs to the electrodes you plan to use.  Then follow the wiring below for your platform to connect the MPR121 to an I2C communication channel.
Raspberry Pi
On a Raspberry Pi connect the hardware as follows.
Note: Make sure you've enabled I2C on your Raspberry Pi!



First make sure that you've installed python.

#+BEGIN_SRC shell
sudo apt-get update
sudo apt-get install build-essential python-dev python-smbus python-pip git

#+END_SRC

Then clone Adafruit_Python_MPR121.git

#+BEGIN_SRC shell
cd ~
git clone https://github.com/adafruit/Adafruit_Python_MPR121.git
#+END_SRC

and install it

#+BEGIN_SRC shell
cd Adafruit_Python_MPR121
sudo python setup.py install

#+END_SRC

** Configuring I2C

I2C is a very commonly used standard designed to allow one chip to talk to another. So, since the Raspberry Pi can talk I2C we can connect it to a variety of I2C capable chips and modules.
Here are some of the Adafruit projects that make use of I2C devices and modules:

https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/configuring-i2c


*** Testing I2C

Now when you log in you can type the following command to see all the connected devices

#+BEGIN_SRC shell
$ sudo i2cdetect -y 1
#+END_SRC


** Usage

#+BEGIN_SRC shell
cd examples
sudo python simpletest.py
#+END_SRC

These are the output values of 12 capacitive touch inputs

0 = 1
1 = 2
2 = 4
3 = 8
4 = 16
5 = 32
6 = 64
7 = 128
8 = 256
9 = 512
10 = 1024
11 = 2048

** Chage permission to read-only files 


#+BEGIN_SRC shell
➜  ~ cd /Volumes
➜  /Volumes ls
Macintosh HD boot
➜  /Volumes cd boot
➜  boot ls
.
➜  boot sudo chmod a+w cmdline.txt
Password:
➜  boot
#+END_SRC





* Shell

** Installing tmux

*tmux* is a "terminal multiplexer", it enables a number of terminals (or windows) to be accessed and controlled from a single terminal. tmux is intended to be a simple, modern, BSD-licensed alternative to programs such as GNU screen.

This release runs on /OpenBSD/, /FreeBSD/, /NetBSD/, /Linux/, /OS X/ and /Solaris/.

tmux depends on *libevent 2.x*. Download it from:

	http://libevent.org

use this command to install it:

#+BEGIN_SRC shell
$ sudo apt-get install libevent-dev
#+END_SRC

It also depends on *ncurses*, available from:

	http://invisible-island.net/ncurses/

to install ncurse open shell and type:

#+BEGIN_SRC shell
$ sudo apt-get install libncurses5-dev libncursesw5-dev
#+END_SRC

To build and install *tmux* from a release tarball, use:

#+BEGIN_SRC shell
$ ./configure && make
$ sudo make install
#+END_SRC

tmux can use the utempter library to update utmp(5), if it is installed - run
configure with --enable-utempter to enable this.

To get and build the latest *tmux* from version control:

#+BEGIN_SRC shell
	$ git clone https://github.com/tmux/tmux.git
	$ cd tmux
	$ sh autogen.sh
	$ ./configure && make
#+END_SRC

to run =sh autogen.sh= you need to install *automake*.

*aclocal* is part of the *automake* package.

#+BEGIN_SRC shell
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install automake
#+END_SRC

To install *tmux* run the following command:

#+BEGIN_SRC shell
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install tmux
#+END_SRC

To run *tmux* open shell and write:

#+BEGIN_SRC shell
tmux
#+END_SRC

see the *tmux* manual here [[http://man.openbsd.org/OpenBSD-current/man1/tmux.1][tmux]]

and here [[https://gist.github.com/MohamedAlaa/2961058][tmux-cheatsheet]]

** Switch to =zsh=

The *Z shell* (zsh) is a Unix shell [...]. Zsh can be thought of as an extended Bourne shell with a large number of improvements, including some features of bash, ksh, and tcsh[fn::https://gist.github.com/derhuerst/12a1558a4b408b3b2b6e].


** Installing zsh on Linux

Some Linux systems come preloaded with zsh. You can check if it exists as well as its version by writing zsh --version in a terminal window. In case this zsh version is ok for you, you're done now!

Determine on which Linux distribution your system is based on. See List of Linux distributions – Wikipedia for a list. Most Linux systems – including Ubuntu – are Debian-based.

Debian-based linux systems

Open a terminal window. Copy & paste the following into the terminal window and hit Return. You may be prompted to enter your password.

#+BEGIN_SRC shell
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install zsh
#+END_SRC

*You can use zsh now*.

to switch from bash to zsh open shell and run the following command:

#+BEGIN_SRC shell
$ chsh -s $(which zsh)
#+END_SRC


To know which shell are you using, use the following command:

#+BEGIN_SRC shell
$ echo $SHELL
#+END_SRC


It will return something like:

=/bin/bash=

or

=/bin/zsh=

After you know the shell, if the file .bashrc or .zshrc doesn't exist in your home directory (echo $HOME to find out), just create it.

If you are using bash, you may have a file called .bash_profile where
you can put your export command instead (don't know in zsh).

** Convert w4a, mp4, etc to wav

install ffmeg
#+BEGIN_SRC shell
$ brew install ffmpeg --with-fdk-aac --with-ffplay --with-freetype --with-libass --with-libquvi --with-libvorbis --with-libvpx --with-opus --with-x265
#+END_SRC

link brew with python

#+BEGIN_SRC shell
brew link python
#+END_SRC

remove existed files
#+BEGIN_SRC shell
rm 'usr/local/Cellar/2to3'
#+END_SRC

convert .m4a to .wav

#+BEGIN_SRC shell
$ ffmpeg -i /Users/sounds/23.3.\ j.m4a  23.3.\ j.wav
#+END_SRC

convert all the files into directory with .wma to mp3

#+BEGIN_SRC shell
$ for file in *.wma; do ffmpeg -i "${file}"  -acodec libmp3lame -ab 192k "${file/.wma/.mp3}"; done
#+END_SRC


* Suggested Bibliography

** Books

